ğŸŒµï¼šè¡¨ç¤ºã€Œèƒ½çŸ¥é“æœ€å¥½ã€ï¼Œå¦‚æœä¸çŸ¥é“ä¹Ÿä¸ä¼šå¯¼è‡´é”™è¯¯ã€‚
ğŸš©ï¼šè¡¨ç¤ºã€Œæœ€èµ·ç è¦çŸ¥é“ã€ï¼Œå¦‚æœä¸çŸ¥é“å¾ˆå¯èƒ½å†™å‡ºä¸å¥½æ‰¾çš„`bug`ã€æ€§èƒ½é—®é¢˜ã€‚
ğŸˆ²ï¼šè¡¨ç¤ºã€Œè¿™ä¸ªå°±åˆ«åšåˆ°äº†ã€ï¼Œå¦‚æœä¸çŸ¥é“å°±éå¸¸å¯èƒ½å‡ºé—®é¢˜ã€‚

# functionå‡½æ•°
`func`æ˜¯`Go`ä¸­çš„ä¸€ç­‰å…¬æ°‘ã€‚

æ‰€è°“ä¸€ç­‰å…¬æ°‘ï¼Œä¹Ÿå°±æ˜¯`func`ç±»å‹å¯ä»¥èµ‹å€¼ç»™å˜é‡ã€å¯ä»¥ä½œä¸ºå‡½æ•°çš„å‚æ•°ã€å¯ä»¥ä½œä¸ºå‡½æ•°çš„è¿”å›å€¼ã€å¯ä»¥è‡ªå®šä¹‰ç±»å‹ï¼Œå¦‚`net/http`åŒ…ä¸­
```go
type HandlerFunc func(ResponseWriter, *Request)
```

## ğŸŒµå‡½æ•°å®šä¹‰çš„è§„èŒƒè¡Œä¸º
### è‹¥å‚æ•°æœ‰context.Contextç±»å‹ï¼Œå¿…åšç¬¬ä¸€ä¸ªå‚æ•°
```go
func getContent(ctx content.Context, ...) error
```

### è‹¥è¿”å›errï¼Œå¿…å°†æœ€åä¸€ä¸ªè¿”å›å€¼
```go
func foo()(int, string, error)
```

### åŒä¸€ç±»å‹çš„å‚æ•°å¯ä»¥åˆå¹¶
**åˆå¹¶åŒç±»é¡¹**

> few params of the same type can be defined in a short way
```go
// lat and log éƒ½æ˜¯float64ç±»å‹
func getCoordinate(lat, log float64) (string, error)
```

### å‡½æ•°åä¸­ç¦æ­¢å‡ºç°`filter`ï¼Ÿ

`filter`æ„æ€ç€â€œè¿‡æ»¤â€ï¼Œæ˜¯ä¸€ç§å¸¸è§çš„æ“ä½œã€‚ä¸ºä½•è¦ç¦æ­¢ä½¿ç”¨ï¼Ÿ

![](media/16633077919315/16643488487757.jpg)


å› ä¸º`filter`è¿‡æ»¤æœ¬èº«å¯ä»¥æœ‰ä¸¤ç§å«ä¹‰ï¼šä½ æ˜¯æƒ³è¦ç•™åœ¨ç­›å­é‡Œé¢çš„ä¸œè¥¿å‘¢ï¼Ÿè¿˜æ˜¯æƒ³è¦è¢«ç­›ä¸‹å»çš„ä¸œè¥¿å‘¢ï¼Ÿ

åœ¨æˆ‘ä»¬çš„é¡¹ç›®ä¸­ï¼Œä¸€èˆ¬æŒ‡çš„æ˜¯ï¼šç»™å®šé›†åˆï¼Œç»™å®šç­›é€‰æ¡ä»¶ï¼Œæˆ‘ä»¬éœ€è¦å¾—åˆ°ç¬¦åˆæ¡ä»¶çš„é›†åˆ

å¯ä»¥ç”¨`match`ã€`qualify`ç­‰è¯æ›¿ä»£

## ğŸš©å…·åè¿”å›å€¼ï¼šè°¨æ…ä½¿ç”¨
### æ˜ç¡®å…·åè¿”å›å€¼æœ¬èº«ä¸æ˜¯å‡½æ•°ç­¾åçš„ä¸€éƒ¨åˆ†

å¦‚ä½•è¯æ˜ï¼Ÿ

```go
type locator interface {
	getCoordinate(address string) (lat, lon float64, err error)
}

type Compass struct{}

func (c Compass) getCoordinate(address string) (float64, float64, error) {
	return 0, 0, nil
}

func main() {
	var l locator
	l = Compass{}

	fmt.Printf("compass is type of locator, %T", l)
}
```
è¯æ¯•

### å­˜åœ¨çš„ç›®çš„ï¼šä¸ºäº†è¡¨è¾¾æ¸…æ™°
```go
// bad 
func getAddress(addr string) (float64, float64, error)

// good 
// å¦‚æ­¤ä¸€æ¥ï¼Œæ›´åŠ æ¸…æ™°
func getAddress(addr string) (lat float64, log float64, err error) 
```

### å‡½æ•°ä½“è¿”å›å€¼çš„é£æ ¼è¦ç»Ÿä¸€

* å¦‚æœå‡½æ•°ä½“æœ¬èº«æ¯”è¾ƒé•¿ï¼Œå°±ä¸è¦çœç•¥`return`çš„å‚æ•°

> if you're going to omit returning params, do it explicitly

å› ä¸ºå…·åè¿”å›å€¼çš„å‡½æ•°ï¼Œå¯ä»¥ä¸å†™å…·ä½“çš„è¿”å›å€¼

```go
// å…³äºå¦‚ä½•å†™å‡ºä¸å¯ç»´æŠ¤çš„ä»£ç ï¼Œæˆ‘â€å…·åè¿”å›å€¼å‡½æ•°â€œæœ‰è¯è¯´
func getLocation(address string) (lat, lng float64, err error) {
	if address == "" {
		return
	}

	if address == "666" {
		return 1, 1, nil
	} else {
		// do something 
		return lat, lng, nil
	}
}
```



## ğŸš©initå‡½æ•°ï¼šèƒ½ä¸ç”¨å°±ä¸ç”¨
é¦–å…ˆçœ‹ä¸‹`init`å†…ç½®å‡½æ•°çš„ç‰¹ç‚¹
### `init`å‡½æ•°çš„ç‰¹ç‚¹

* `init`å’Œ`main`ä¸€æ ·ï¼Œå‡ä¸º`func()` å‡½æ•°ç±»å‹ï¼š æ— å‚æ•°ã€æ— è¿”å›å€¼

* åœ¨`Go`ä¸­åˆå§‹åŒ–ä¸€ä¸ª`package`çš„æµç¨‹ï¼šé¦–å…ˆåˆå§‹åŒ–`package`ä¸­çš„å¸¸é‡ã€å˜é‡ï¼Œç„¶åå°±æ˜¯`init`å‡½æ•°

* ä¸€ä¸ª`package`ä¸­å¯ä»¥æœ‰å¤šä¸ª`init`å‡½æ•°ï¼Œç”šè‡³ä¸€ä¸ªæ–‡ä»¶ä¸­éƒ½å¯ä»¥å®šä¹‰å¤šä¸ª`init`å‡½æ•°ã€‚æŒ‰ç…§â€å…ˆåˆ°å…ˆå¾—â€œçš„é¡ºåºæ‰§è¡Œ

### `init`å‡½æ•°çš„ç¼ºç‚¹

* æ— æ³•å¾ˆå¥½çš„å¤„ç†`init`å†…éƒ¨çš„`error`ï¼Œå› ä¸ºæ— æ³•è¿”å›å€¼

* ä¸èƒ½æ–¹ä¾¿çš„æµ‹è¯•`init`ä¸­çš„é€»è¾‘

* å¦‚æœåœ¨`init`ä¸­åˆå§‹åŒ–èµ„æºï¼Œéœ€è¦æå‰å£°æ˜å…¨å±€å˜é‡ï¼Œç„¶åèµ‹å€¼ç»™å®ƒã€‚è€Œå…¨å±€å˜é‡çš„ä½¿ç”¨è¿ˆå‘äº†å¦å¤–çš„å……æ»¡å‘çš„ä¸–ç•Œã€‚

<table>
<thead><tr><th>Bad</th><th>Good</th></tr></thead>
<tbody>
<tr><td>

```go
type Foo struct {
    // ...
}

var _defaultFoo Foo

func init() {
    _defaultFoo = Foo{
        // ...
    }
}
```

</td><td>

```go
var _defaultFoo = Foo{
    // ...
}

// or, better, for testability:

var _defaultFoo = defaultFoo()

func defaultFoo() Foo {
    return Foo{
        // ...
    }
}
```

</td></tr>
<tr><td>

```go
type Config struct {
    // ...
}

var _config Config

func init() {
    // Bad: based on current directory
    cwd, _ := os.Getwd()

    // Bad: I/O
    raw, _ := os.ReadFile(
        path.Join(cwd, "config", "config.yaml"),
    )

    yaml.Unmarshal(raw, &_config)
}
```
</td><td>

```go
type Config struct {
    // ...
}

func loadConfig() Config {
    cwd, err := os.Getwd()
    // handle err

    raw, err := os.ReadFile(
        path.Join(cwd, "config", "config.yaml"),
    )
    // handle err

    var config Config
    yaml.Unmarshal(raw, &config)

    return config
}
```
</td></tr>
</tbody></table>

### `init`ä¸‡ä¸€ä½¿ç”¨ï¼Œéœ€è¦æ»¡è¶³
1. Be completely deterministic, regardless of program environment or invocation.

2. Avoid depending on the ordering or side-effects of other `init()` functions.
   While `init()` ordering is well-known, code can change, and thus
   relationships between `init()` functions can make code brittle and
   error-prone.

3. Avoid accessing or manipulating global or environment state, such as machine
   information, environment variables, working directory, program
   arguments/inputs, etc.

4. Avoid I/O, including both filesystem, network, and system calls.

### ä½¿ç”¨`init`å‡½æ•°çš„æˆåŠŸæ¡ˆä¾‹

todo Go sql
[design-patterns-in-gos-databasesql-package](https://eli.thegreenplace.net/2019/design-patterns-in-gos-databasesql-package/)

## ğŸš©åªåœ¨`main`å‡½æ•°ä¸­é€€å‡º
ä½¿ç”¨`os.Exit`æˆ–è€…`log.Fatal`é€€å‡º

`log.Fatal`å†…éƒ¨ä½¿ç”¨`os.Exit`

## ğŸš©å°½é‡ä¸è¦ä½¿ç”¨`new`
å› ä¸º`new`èƒ½åšåˆ°çš„ï¼Œå…¶ä»–çš„æ–¹å¼éƒ½èƒ½åšåˆ°ï¼Œè€Œä¸”åšå¾—æ›´å¥½ã€‚

<table>
<thead><tr><th>Bad</th><th>Good</th></tr></thead>
<tbody>
<tr><td>

```go
sval := T{Name: "foo"}

// inconsistent
sptr := new(T)
sptr.Name = "bar"
```

</td><td>

```go
sval := T{Name: "foo"}

sptr := &T{Name: "bar"}
```

</td></tr>
</tbody></table>

## ğŸš©deferå‡½æ•°ï¼šåˆç†ä½¿ç”¨
### deferçš„å®šä¹‰
> A defer statement defers the execution of a function until the surrounding function returns.

ä¸€å¥è¯æ€»ç»“ï¼š`defer`å°±æ˜¯ç”¨æ¥å»¶è¿Ÿæ‰§è¡Œå‡½æ•°çš„æŠ€æœ¯æ‰‹æ®µã€‚

è™½ç„¶åªæœ‰çŸ­çŸ­ä¸€å¥è¯ï¼Œä½†æ˜¯æˆ‘ä»¬ä¹Ÿå¯ä»¥è·å¾—å¾ˆå¤šã€‚

æ¥æ¥æ¥ï¼Œæˆ‘ä»¬å…ˆæ¥æ€»ç»“ä¸€ä¸‹ï¼Œï¼ˆæ›´å¤šçš„å†…å®¹å°†åœ¨ä¸‹æ–‡å±•å¼€è®ºè¿°ï¼‰ã€‚

1ã€`defer`åé¢è·Ÿå‡½æ•°:`defers the execution of a `**`function`**ã€‚

2ã€`defer`çš„ä½œç”¨å°±æ˜¯æ¿€æ´»åæ¥çš„å‡½æ•°:`the execution`.

3ã€è¿è¡Œæ—¶æœº:`until the surrounding function returns`.

> A "defer" statement invokes a function whose execution is deferred to the moment the surrounding function returns, either because the surrounding function executed a return statement, reached the end of its function body, or because the corresponding goroutine is panicking.

### ä¸ºä»€ä¹ˆè¦æœ‰defer
å†æ¬¡é‡ç”³ï¼Œ**`defer`çš„æœ¬è´¨å°±æ˜¯å»¶è¿Ÿè‡ªåŠ¨æ‰§è¡Œå‡½æ•°**ã€‚

å®ƒçš„å‡ºç°å°±æ˜¯ä¸ºäº†æ›´åŠ ä¾¿åˆ©çš„è¿›è¡Œèµ„æºç®¡ç†ï¼Œå‡è½»ç¨‹åºå‘˜çš„å¿ƒæ™ºè´Ÿæ‹…ï¼Œæé«˜ä»£ç çš„å¯è¯»æ€§ã€å¯ç»´æŠ¤æ€§å’Œå¯æ‰©å±•æ€§ã€‚

å‡å¦‚`Go`æ²¡æœ‰`defer`æœºåˆ¶ï¼Œä¸ºäº†å®ç°ä¸€ä¸ªå—ä¿æŠ¤çš„æ–‡ä»¶æ“ä½œã€‚æˆ‘ä»¬å¾—è¿™ä¹ˆå†™

```Go
func writeToFile(fname string, data []byte, mu *sync.Mutex) error {
    mu.Lock()
    f, err := os.OpenFile(fname, os.O_RDWR, 0666)
    if err != nil {
    mu.Unlock()
    return err
    }

    _, err = f.Seek(0, 2)
    if err != nil {
        f.Close()
        mu.Unlock()
        return err
    }

    _, err = f.Write(data)
    if err != nil {
        f.Close()
        mu.Unlock()
        return err
    }

    err = f.Sync()
    if err != nil {
        f.Close()
        mu.Unlock()
        return err
    }

    err = f.Close()
    if err != nil {
        mu.Unlock()
        return err
    }

    mu.Unlock()
    return nil
}
```

å°±åƒè€å¥¶å¥¶çš„è£¹è„šå¸ƒâ€”â€”åˆè‡­åˆé•¿ã€‚

ç¨‹åºå‘˜æ¯æ¬¡æ“ä½œï¼Œéƒ½å¾—å¤„ç†èµ„æºçš„é‡Šæ”¾ï¼šé”çš„é‡Šæ”¾ã€æ–‡ä»¶å¥æŸ„çš„å…³é—­ã€‚ä»…ä»…ä¸¤ä¸ªèµ„æºçš„é‡Šæ”¾æ“ä½œï¼Œå°±å¾—ã€å¦‚ä¸´æ·±æ¸Šï¼Œå¦‚å±¥è–„å†°ã€ã€‚å¢åŠ èµ„æºçš„å‚ä¸æ•°ï¼Œé‚£ç®€ç›´ä¸å ªè®¾æƒ³ã€‚

å¹¸å¥½ï¼Œæˆ‘ä»¬çš„`Go`æœ‰`defer`æœºåˆ¶ï¼Œæˆ‘ä»¬å¯ä»¥æ”¹å†™å¦‚ä¸‹

```go
func writeToFile(fname string, data []byte, mu *sync.Mutex) error {

    mu.Lock()
    defer mu.Unlock()

    f, err := os.OpenFile(fname, os.O_RDWR, 0666)
    if err != nil {
        return err
    }
    defer f.Close()
    
    _, err = f.Seek(0, 2)
    if err != nil {
        return err
    }

    _, err = f.Write(data)
    if err != nil {
        return err
    }

    return f.Sync()
}
```

æˆ‘ä»¬æ‰€éœ€è¦åšçš„å°±æ˜¯ç”³è¯·èµ„æºä¹‹åï¼Œé©¬ä¸Š`defer+`é‡Šæ”¾èµ„æºçš„é€»è¾‘ã€‚å½“`writeToFile`è¿è¡Œç»“æŸæ—¶ï¼Œä¼šè‡ªåŠ¨é‡Šæ”¾é”å’Œå…³é—­æ–‡ä»¶å¥æŸ„ã€‚

### deferçš„ç‰¹æ€§

ä¸Šé¢å¯¹`defer`çš„æè¿°ï¼Œåªæ˜¯éå¸¸ç²—ç³™çš„è®²è§£ã€‚ä¸‹é¢è®²è¿°ä¸ºäº†é‡Šæ”¾èµ„æºï¼Œå»¶è¿Ÿæ‰§è¡Œï¼Œ`defer`çš„å…·ä½“è§„å®šç»†èŠ‚ã€‚

æ¯”å¦‚

`defer`åæ¥å‡½æ•°ï¼Œé‚£ä¹ˆå‡½æ•°çš„å‚æ•°ä»€ä¹ˆæ—¶å€™ç¡®å®šï¼Ÿï¼ˆè¦çŸ¥é“åŒæ ·çš„å˜é‡ï¼Œåœ¨å‡½æ•°é€€å‡ºæ—¶ä¸åˆšè¿›å…¥å‡½æ•°æ—¶ï¼Œå†…å®¹å¯èƒ½æ˜¯ä¸ä¸€æ ·çš„ï¼‰å¯ä»¥åæ¥æ–¹æ³•å—ï¼Ÿ

`defer`åçš„å‡½æ•°çœŸæ­£æ‰§è¡Œæ—¶æœºæ˜¯ï¼šå£°æ˜`defer`è¡¨è¾¾å¼çš„å‡½æ•°æ‰§è¡Œç»“æŸæ—¶ã€‚é‚£ä¹ˆè¿™ä¸ªæ‰€è°“çš„å‡½æ•°æ‰§è¡Œç»“æŸæ—¶ï¼Œæ˜¯è¿”å›åï¼Œè¿˜æ˜¯è¿”å›å‰ï¼Ÿè¿˜æ˜¯å…¶ä»–ä»€ä¹ˆæ—¶é—´ç‚¹ï¼Ÿ

å¦‚æœä¸€ä¸ªå‡½æ•°ä¹‹ä¸­ï¼Œå£°æ˜äº†å¤šä¸ª`defer`è¡¨è¾¾å¼ï¼Œè™½ç„¶éƒ½æ˜¯å‡½æ•°é€€å‡ºæ—¶è°ƒç”¨ï¼Œä½†æ˜¯å®ƒä»¬æ‰§è¡Œçš„é¡ºåºå¦‚ä½•ï¼Ÿéšæœºçš„ï¼Ÿï¼ˆåƒ`select channel`ä¸€æ ·ï¼‰ï¼Ÿå…ˆè¿›å…ˆå‡ºï¼Ÿï¼ˆè¶Šå…ˆè¢«`defer`çš„å‡½æ•°è¶Šæ—©è°ƒç”¨ï¼‰ï¼Ÿå…ˆè¿›åå‡ºï¼Ÿ

æ¥å§ï¼Œè®©æˆ‘ä»¬å›ç­”ä¸Šé¢çš„é—®é¢˜ã€‚

ä¸è¿‡åœ¨æ­¤ä¹‹å‰ï¼Œå­¦ä¹ ä¸¤ä¸ªè‹±æ–‡å•è¯ã€‚

`execution`ï¼šä¸­æ–‡æ˜¯æ‰§è¡Œçš„æ„æ€ã€‚æ¯”å¦‚å‡½æ•°çš„æ‰§è¡Œï¼Œå°±æ˜¯è¿è¡Œå‡½æ•°çš„æ„æ€ã€‚

`evaluate`ï¼šä¸­æ–‡æ˜¯è¯„ä»·ã€ä¼°è®¡çš„æ„æ€ã€‚åœ¨ç¼–ç¨‹é‡Œé¢ï¼Œæ¯”å¦‚å‡½æ•°å‚æ•°ï¼Œå½“æˆ‘ä»¬è¯´`evaluate function parameters`ï¼Œå°±æ˜¯ç¡®å®šå‡½æ•°å‚æ•°å€¼çš„æ„æ€ã€‚å—¯ï¼Œ`evaluate`å¯ä»¥ç¿»è¯‘æˆç¡®å®šã€‚

ä¸‹é¢è¿›å…¥æ­£é¢˜

1ã€defered function evaluates its parameter when is occur

è¢«`defer`çš„å‡½æ•°ä¼šç«‹é©¬ç¡®å®šåæ¥å‡½æ•°å‚æ•°

```go
func print(num int) {
    fmt.Println(num)
}

func foo() {
    var i = 666
    defer print(i)
    
    i = 888
    return
}

func main() {

    foo()
}
```

ä¼šæ‰“å°`666`ã€‚è¿™å°±å«åšå½“å‡ºç°`defer`æ—¶ï¼Œåæ¥å‡½æ•°çš„å‚æ•°ç«‹é©¬è¢«ç¡®å®šï¼Œå³`i=666`ã€‚è™½ç„¶`defer`åœ¨åé¢æ‰ä¼šæ‰§è¡Œï¼Œä½†æ˜¯å‚æ•°çš„ç¡®å®šæ˜¯åœ¨ä¸€å¼€å§‹å°±ç¡®å®šäº†ã€‚

2ã€defered function will execute before real return

è¢«`defer`çš„å‡½æ•°ä¼šåœ¨è°ƒç”¨å®ƒçš„å‡½æ•°è¿”å›å‰æ‰§è¡Œ

è¿™å¥è¯ä¸å¥½ç†è§£ã€‚é‡ç‚¹åœ¨äºä»€ä¹ˆå«åš`real return`ã€‚

ä¼‘æ¯ä¸€ä¸‹ï¼Œä¸‹é¢çš„ä¾‹å­éœ€è¦ä»”ç»†çœ‹

```go
func sara() (result int) {

    result = 1

    defer func() {
        result = 666
    }()

    return result

}

func lisa() int {

    var result = 1
    
    defer func() {
        result = 666
    }()

    return result
}

func main() {

    r := sara()
    fmt.Printf("sara finially result, %d\n", r) // 666

    r = lisa()
    fmt.Printf("lisa finially result, %d\n", r) // 1
}
```

å¯ä»¥è§‚å¯Ÿåˆ°ï¼Œ`sara`å’Œ`lisa`åŸºæœ¬é€»è¾‘æ˜¯ä¸€æ ·çš„ï¼Œå”¯ä¸€çš„ä¸åŒå°±æ˜¯`sara`æ˜¯å…·åè¿”å›å€¼å‡½æ•°ï¼Œè€Œ`lisa`æ˜¯åŒ¿åè¿”å›å€¼å‡½æ•°ã€‚è¿™å°±æ˜¯å¤§å¤§çš„ä¸åŒäº†ã€‚

å¥½å¥½ç†è§£ä¸€ä¸‹ä¸Šé¢çš„ä¾‹å­ï¼Œä¸‹é¢ç»™å‡º`go`å‡½æ•°çš„è¿”å›å€¼æ¨¡å‹

å…¶å®`go`çš„`return`è¯­å¥æ˜¯åˆ†æˆä¸¤éƒ¨åˆ†çš„ã€‚æ¯”å¦‚å¯¹äºåŒ¿åè¿”å›å€¼å‡½æ•°`lisa`æ¥è¯´

```go
return result
ç›¸å½“äº

1ã€var ret = result // ret æ˜¯çœŸè¿”å›å€¼
2ã€return ret
```

å¯¹äºå…·åè¿”å›å€¼å‡½æ•°saraæ¥è¯´

```go
return result
ç›¸å½“äº

1ã€var result = result
2ã€return result
```

æ³¨æ„ä¸¤è€…çš„åŒºåˆ«ã€‚

é‡ç‚¹æ¥å•¦ï¼Œ`defer`çš„è¿è¡Œæ—¶æœºå°±æ˜¯æ­¥éª¤`1`å’Œæ­¥éª¤`2`ä¹‹é—´ï¼

æ‰€ä»¥å¯¹äº`lisa`æ¥è¯´ï¼Œæˆ‘è¦è¿”å›çš„æ˜¯`ret`ï¼Œå°±ç®—ä½ åœ¨`defer`ä¸­ä¿®æ”¹äº†`result`ï¼Œä¹Ÿä¸ä¼šå½±å“åˆ°æœ€ç»ˆè¿”å›å€¼å“¦ã€‚ä½†æ˜¯`sara`å°±ä¸ä¸€æ ·äº†ï¼Œå¥¹è¿”å›çš„å°±æ˜¯`result`ï¼Œåœ¨`defer`ä¸­ä¿®æ”¹äº†`result`ï¼Œæœ€ç»ˆçš„ç»“æœå°±ä¸ä¸€æ ·å•¦ã€‚

å’³å’³ï¼Œå…·åè¿”å›å€¼å’Œ`defer`çš„è”åˆä½¿ç”¨ï¼Œè¦æ³¨æ„å“¦ğŸ˜‘ã€‚åˆ«å†™è¿™æ ·çš„ä»£ç ã€‚

3ã€å¤šä¸ª`defer`çš„æ‰§è¡Œçš„é¡ºåºæ˜¯ï¼šåè¿›å…ˆå‡ºï¼Œç±»ä¼¼æ ˆ

```golang
func print(num int) {
    fmt.Println(num)
}

func bob() {
    defer print(1)
    defer print(2)
    defer print(3)

    return

}

func main() {
    bob()
}
```

ä¼šæ‰“å°

```text
3
2
1
```

### å¦‚ä½•è®°ä½deferçš„ç‰¹æ€§

`defer`å‡ºç°å°±æ˜¯ä¸ºäº†èµ„æºçš„ç®¡ç†ã€‚

æ¯”å¦‚å¦‚æœæœ‰ä»¥ä¸‹è¿™ä¸ªè¿‡ç¨‹ï¼šé¦–å…ˆè·å–èµ„æº`A`ï¼Œç„¶åè·å–èµ„æº`B`ï¼Œæœ€åè·å–èµ„æº`C`æ‰èƒ½æ‰§è¡ŒæŸä¸ªæ“ä½œï¼Œé‚£ä¹ˆ`defer`çš„é¡ºåºï¼Œè‚¯å®šæ˜¯å…ˆæ”¾å›`C`èµ„æºï¼Œç„¶å`B`èµ„æºï¼Œæœ€åæ˜¯`A`èµ„æºã€‚

è¿™ä¸ªè¿‡ç¨‹è®©æˆ‘æƒ³èµ·æ¥çš„ä¸¾è¯çš„ä¹˜æ³•å’Œé€†è¿ç®—â€”â€”é€†çŸ©é˜µã€‚

æ¯”å¦‚`AB`ï¼Œè¡¨ç¤ºçŸ©é˜µ`A`ä¹˜ä»¥çŸ©é˜µ`B`ï¼Œé‚£ä¹ˆå®ƒä¿©çš„é€†è¿ç®—å‘¢ï¼Ÿ

$(AB)^{-1} = B^{-1}A^{-1}$

å½“æ—¶ä¸ºäº†è®°ä½è¿™ä¸ªç‰¹æ€§ï¼Œæˆ‘æ˜¯è®°ä½äº†ä¸‹é¢çš„è¿™ä¸ªç±»æ¯”ï¼š

å…ˆç©¿è¢œå­ï¼Œç„¶åç©¿è£¤å­ï¼›å¦‚æœè¿™ä¸€è¿‡ç¨‹åè¿‡æ¥ï¼Œé‚£å°±æ˜¯å…ˆæ‹–é‹ï¼Œå†è„±è¢œå­ã€‚

`nice`ã€‚

å¦‚ä»Šçœ‹æ¥ï¼Œä¸è®ºæ˜¯ç©¿è¡£æœã€çŸ©é˜µä¹˜æ³•ã€èµ„æºçš„ç®¡ç†ï¼Œéƒ½æ˜¯ä¸€ç§è¡Œä¸ºã€ä¸€ç§è¿åŠ¨ã€ä¸€ç§å˜åŒ–ã€‚ä»–ä»¬æ˜¯åˆ†å…ˆåçš„ï¼Œæ‰€ä»¥ä»–ä»¬çš„â€œåè¿åŠ¨â€è¦ä¸æ­£å‘è¿åŠ¨ç›¸åã€‚

### ä¸è¦åœ¨å¾ªç¯ä¸­æ»¥ç”¨defer
è¯¦è§Goç¼–ç¨‹æŒ‡å¼•ä¸é™·é˜±1ä¸­çš„forå¾ªç¯ç« èŠ‚


## ğŸš©å¯¹å‡½æ•°è¿›è¡Œæ˜¾ç¤ºç±»å‹è½¬æ¢
åƒå¯¹æ•´å‹å˜é‡é‚£æ ·`int64(13240366)`
```go
func greeting(w http.ResponseWriter, r *http.Request) {
	fmt.Fprintf(w, "Welcome, Gopher!\n")
}

func main() {
    // ç›´æ¥ä¼ é€’greetingæ˜¯ä¼šå‡ºé”™çš„!

	//http.ListenAndServe(":8080", http.HandlerFunc(greeting))
	http.ListenAndServe(":8080", greeting) 
}
```
`ps`ï¼šç»è¿‡`http.HandlerFunc`è½¬æ¢ä¹‹åå°±å¯ä»¥ç”¨äº†å“ˆã€‚

(å¦‚æœå¯¹æ­¤æ„Ÿå…´è¶£ï¼Œå¯å‚è€ƒæœ¬äººæ‹™ä½œ[Goè¯­è¨€ç³»åˆ—ä¹‹HTTPæœåŠ¡å™¨](https://zhuanlan.zhihu.com/p/588192056?))

æœ¬è´¨ä¸Šç›¸åŒçš„è¡Œä¸º
```go
type BinaryAdder interface {
	Add(int, int) int
}

// å®ç°BinaryAdderæ¥å£
type MyAdderFunc func(int, int) int

func (f MyAdderFunc) Add(x, y int) int {
	return f(x, y)
}

func MyAdd(x, y int) int {
	return x + y
}

func main() {
	var i BinaryAdder = MyAdderFunc(MyAdd)
	fmt.Println(i.Add(5, 6))
}
```

## ğŸš©äº†è§£å˜é•¿å‚æ•°çš„å¦™ç”¨
### åŸºæœ¬ç‰¹ç‚¹-å¸¸è§
å¦‚åŒç©ºæ°”ä¸€èˆ¬ï¼Œå¸¸è§å¸¸ç”¨ä½†å¾€å¾€æ²¡æœ‰å¼•èµ·äººä»¬çš„æ³¨æ„ã€‚
æ¯”å¦‚
```go
func Printf(format string, a ...interface{}) (n int, err error) 

func Sprintf(format string, a ...interface{}) string 

func append(slice []Type, elems ...Type) []Type
```
### åŸºæœ¬ä½¿ç”¨
* å‡½æ•°å†…ä½¿ç”¨-å¦‚åŒåˆ‡ç‰‡ä¸€èˆ¬
```go
func sum(arr ...int) int {
	var t int
	for _, n := range arr {
		t += n
	}
	return t
}
```

* å‡½æ•°å¤–ä½¿ç”¨

1ã€å¯`t...`ä½¿ç”¨ï¼Œå…¶ä¸­`t`æ˜¯`[]T`åˆ‡ç‰‡ç±»å‹

2ã€å¯å¤šä¸ª`T`ä½¿ç”¨
```go
// ok
sum(1,2,3)
sum([]int{1,2,3}...)
	
// not ok 
sum([3]int{1,2,3}...) // Cannot use '[3]int{1,2,3}' (type [3]int) as the type []int
```

### å®å‚ä¸å½¢å‚ä¸åŒ¹é…çš„é—®é¢˜
```go
func dump(args ...interface{}) {
	for _, v := range args {
		fmt.Println(v)
	}
}

func main() {
	//s := []string{"Tony", "John", "Jim"} // not ok ï¼Œç±»å‹ä¸åŒ¹é…
	s := []interface{}{"Tony", "John", "Jim"}
	dump(s...)
}
```
`ps`:éƒ½æ€ªæ ‡å‡†åº“é‡Œé¢çš„`printf`ğŸ˜‚

### å˜é•¿å‚æ•°+ç±»å‹éªŒè¯=é‡è½½å‡½æ•°
* ä¸€ä¸ªæˆ‘ä»¬éœ€è¦çš„æ‹¼æ¥å‡½æ•°
```go

// SliceJoin é‡è½½ä¹‹
func SliceJoin(sep string, nums ...interface{}) string {
	if len(nums) == 0 {
		return ""
	}

	var arr = make([]string, 0, len(nums))
	for _, num := range nums {
		switch num.(type) {
		case int64, uint32, int:
			arr = append(arr, fmt.Sprintf("%d", num))
		case string:
			arr = append(arr, fmt.Sprintf("%s", num))

		case []string:
			arr = append(arr, num.([]string)...)
		case []uint32:
			for _, e := range num.([]uint32) {
				arr = append(arr, fmt.Sprintf("%d", e))
			}
		case []int64:
			for _, e := range num.([]int64) {
				arr = append(arr, fmt.Sprintf("%d", e))
			}
		case []int:
			for _, e := range num.([]int) {
				arr = append(arr, fmt.Sprintf("%d", e))
			}
		}
	}
	return strings.Join(arr, sep)
}

func main() {
	fmt.Println("int", SliceJoin(",", []int{1, 2, 3}))                 // int 1,2,3
	fmt.Println("int64", SliceJoin(",", []int64{1, 2, 3}))             // int64 1,2,3
	fmt.Println("uint32", SliceJoin(",", []uint32{1, 2, 3}))           // uint32 1,2,3
	fmt.Println(SliceJoin("-", 1, 2, "sr", "z7", "x", []int{1, 2, 3})) // 1-2-sr-z7-x-1-2-3
}
```

### åŠŸèƒ½é€‰é¡¹æ¨¡å¼
å¦‚ä½•æ„å»ºä¸€ä¸ªåˆç†çš„æ„å»ºå‡½æ•°ï¼Ÿ

å°¤å…¶æ˜¯å½“æ„å»ºçš„`struct`æœ‰å¤šä¸ªå­—æ®µï¼Œä¸åŒçš„è°ƒç”¨æ–¹éœ€è¦ä¸åŒçš„é…ç½®ã€‚æˆ‘ä»¬æ€ä¹ˆåšæ‰èƒ½æä¾›ä¸€ä¸ªåˆç†çš„æ„å»ºå‡½æ•°å‘¢ï¼Ÿ

è¿™å°±æ˜¯æœ¬èŠ‚éœ€è¦è®¨è®ºçš„é—®é¢˜ã€‚
```go
// æˆ¿å­è£…ä¿®é£æ ¼
type FinishedHouse struct {
	style                  int    // 0: Chinese, 1: American, 2: European
	centralAirConditioning bool   // true or false
	floorMaterial          string // "ground-tile" or â€wood"
	wallMaterial           string // "latex" or "paper" or "diatom-mud"
}

type Option func(*FinishedHouse) // æ— è¿”å›å€¼

func NewFinishedHouse(options ...Option) *FinishedHouse {
	h := &FinishedHouse{
		// é»˜è®¤é€‰é¡¹
		style:                  0,
		centralAirConditioning: true,
		floorMaterial:          "wood",
		wallMaterial:           "paper",
	}

	for _, option := range options {
		option(h)
	}

	return h
}

func WithStyle(style int) Option {
	return func(h *FinishedHouse) {
		h.style = style
	}
}

func WithFloorMaterial(material string) Option {
	return func(h *FinishedHouse) {
		h.floorMaterial = material
	}
}

func WithWallMaterial(material string) Option {
	return func(h *FinishedHouse) {
		h.wallMaterial = material
	}
}

func WithCentralAirConditioning(centralAirConditioning bool) Option {
	return func(h *FinishedHouse) {
		h.centralAirConditioning = centralAirConditioning
	}
}

func main() {
	fmt.Printf("%+v\n", NewFinishedHouse()) // use default options
	fmt.Printf("%+v\n", NewFinishedHouse(WithStyle(1),
		WithFloorMaterial("ground-tile"),
		WithCentralAirConditioning(false)))
}
```

# method
`Go`æ–¹æ³•çš„æœ¬è´¨ï¼šå°±æ˜¯ä»¥`receiver`ç±»å‹çš„å®ä¾‹ä½œä¸ºç¬¬ä¸€ä¸ªå‚æ•°çš„**å‡½æ•°**ã€‚

## ğŸš©ç±»å‹ä¸å…¶æ–¹æ³•å®šä¹‰åœ¨åŒä¸€ä¸ªåŒ…

## ğŸš©å¯ä»¥ç»‘å®šmethodçš„ç±»å‹
`receiver`å‚æ•°çš„åŸºç±»å‹æœ¬èº«ä¸èƒ½æ˜¯æŒ‡é’ˆç±»å‹/æ¥å£ç±»å‹

> methods can be defined for any named type (except a pointer or an interface); the receiver does not have to be a struct.
> -- < Effective Go >

```go
// pointeræŒ‡é’ˆä¸èƒ½ç»‘å®šmethod
type PtrInt *int

// error: Invalid receiver type 'PtrInt' ('PtrInt' is a pointer type)
func (p PtrInt) Hello() {
	fmt.Println("hello")
} 
```

## ğŸš©æ˜æ™°value & pointer receiver

* ä»€ä¹ˆæ˜¯`value receiver`,ä»€ä¹ˆæ˜¯`pointer receiver`ï¼Ÿ
```go
type Person struct {
	Name string
}

// value receiver
func (p Person) GetName() string {
	return p.Name
}

// pointer receiver
func (p *Person) SetName(name string) {
	p.Name = name
}
```

ä¸‹é¢æ¥è®¨è®ºä¸¤è€…ä¹‹é—´çš„åŒºåˆ«ã€‚

å…¶å®`Go`çš„`value/pointer receiver`åŒºåˆ«éå¸¸æ˜æ˜¾ã€ç®€å•ã€‚æ€»ç»“æ¥è¯´ï¼Œå°±æ˜¯å¦‚ä¸‹ï¼š

> value methods can be invoked by value and pointer receiver, but pointer methods can be only invoked by pointer receiver.

ç¿»è¯‘ä¸€ä¸‹å°±æ˜¯
 ```go
// value receiver
value := Person{}

// pointer receiver
pointer := &Person{}

// value methods can be invoked by value and pointer receiver
// GetNameæ˜¯ä¸€ä¸ªvalue method
value.GetName()
pointer.GetName()

//	pointer methods can be only invoked by pointer receiver.
// SetNameæ˜¯ä¸€ä¸ªpointer method
pointer.SetName("xxx")
 ```
å¦‚ä¸Šæ‰€è¿°ï¼Œè¿™å¾ˆå¥½ç†è§£ã€‚

ä½†è®©äººéœ‡æƒŠçš„æ˜¯ï¼Œæˆ‘ä»¬ä¹Ÿå¯ä»¥è¿™ä¹ˆç”¨
 ```go
 value.SetName("why") // it's ok,ä¸ä¼šæŠ¥é”™
 ```

ä¸Šé¢ä¸æ˜¯è¯´`pointer methods can be only invoked by pointer receiver.`å—ï¼Ÿ

`SetName`ä½œä¸ºä¸€ä¸ª`pointer method`ï¼Œè¢«`pointer receiver`è°ƒç”¨ï¼Œè¿™æ²¡é—®é¢˜ã€‚ä¸ºä»€ä¹ˆä¹Ÿèƒ½è¢«`value receiver`è°ƒç”¨ï¼Ÿè¿™ç©¶ç«Ÿæ˜¯ä¸ºä»€ä¹ˆï¼Ÿ

æ ¹æœ¬åŸå› æ˜¯Goä¼šé»˜é»˜çš„åšéšå¼è½¬æ¢ã€‚è€Œæˆ‘è®¤ä¸ºï¼Œ**è¿™ä¸ªé—®é¢˜å› ä¸ºGoçš„éšå¼è½¬æ¢å°†å…¶å¤æ‚åŒ–äº†**ã€‚

* `Go`ä¼šå¸®æˆ‘ä»¬åšé»˜è®¤çš„è½¬åŒ–ã€‚

```go
// ä¸ç®¡æ˜¯val / pointer receiver,éƒ½å¯ä»¥é€šè¿‡è¯­æ³•ç³–çš„å½¢å¼è°ƒç”¨ pointer/val receiver method

package main

import "fmt"

type printer interface {
	print()
}

// method with value receiver
type S struct{}

func (s S) print() {
	fmt.Println("hello S")
}

// method with pointer receiver
type P struct{}

func (p *P) print() {
	fmt.Println("hello P")
}

func main() {
		// step 1
	s := S{}
	s.print()

	ps := &S{}
	ps.print() // (*ps).print()

	p := P{}
	p.print() // (&p).print()

	pp := &P{}
	pp.print()

	// step 2
	m := map[int]P{1: {}}
	m[1].print() // cannot take the address of m[1]

	// step 3
	var _ printer = S{}
	var _ printer = &S{}

	var _ printer = P{} // compile error
	var _ printer = &P{}
}
```

**Methods with value receivers can be called on pointers as well as values. Methods with pointer receivers can only be called on pointers or addressable values.**
ä¸ºä»€ä¹ˆè¦æœ‰ä»¥ä¸Šçš„è§„å®šï¼Ÿ

## ğŸš©value receiveræ˜¯éœ€è¦å¤åˆ¶ç±»å‹çš„
åŸå› å¾ˆç®€å•ï¼Œå› ä¸º`method`å°±æ˜¯`function`ï¼Œ`value receiver`ä½œä¸ºå‡½æ•°çš„ç¬¬ä¸€ä¸ªå‚æ•°ï¼Œæœ¬è´¨ä¸Šå°±æ˜¯å¤åˆ¶ã€‚

```go
package main

import "fmt"

type Container struct {
  i int
  s string
}

func (c Container) byValMethod() {
  fmt.Printf("byValMethod got &c=%p, &(c.s)=%p\n", &c, &(c.s))
}

func (c *Container) byPtrMethod() {
  fmt.Printf("byPtrMethod got &c=%p, &(c.s)=%p\n", c, &(c.s))
}

func main() {
  var c Container
  fmt.Printf("in main &c=%p, &(c.s)=%p\n", &c, &(c.s))

  c.byValMethod()
  c.byPtrMethod()
}

// result 
in main &c=0xc00000a060, &(c.s)=0xc00000a068
byValMethod got &c=0xc00000a080, &(c.s)=0xc00000a088
byPtrMethod got &c=0xc00000a060, &(c.s)=0xc00000a068
```
## ğŸš©ä¿®æ”¹ç±»å‹çŠ¶æ€è¦ç”¨pointer receiver
```go
package main

import (
  "fmt"
  "sync"
  "time"
)

type Container struct {
  sync.Mutex                       // <-- Added a mutex
  counters map[string]int
}

func (c Container) inc(name string) {
  c.Lock()                         // <-- Added locking of the mutex
  defer c.Unlock()
  c.counters[name]++
}

func main() {
  c := Container{counters: map[string]int{"a": 0, "b": 0}}

  doIncrement := func(name string, n int) {
    for i := 0; i < n; i++ {
      c.inc(name)
    }
  }

  go doIncrement("a", 100000)
  go doIncrement("a", 100000)

  // Wait a bit for the goroutines to finish
  time.Sleep(300 * time.Millisecond)
  fmt.Println(c.counters)
}
```
è¿™æ®µç¨‹åºä¼španicã€‚ä½†åªè¦ä¿®æ”¹ä¸€ä¸ªå­—ç¬¦å°±å¯ä»¥å®Œç¾è¿è¡Œã€‚

## ğŸŒµmethodçš„æ¥å—è€…ç±»å‹æœ€å¥½ç»Ÿä¸€
**è¦ä¹ˆå…¨æ˜¯`method with value`ï¼Œè¦ä¹ˆå…¨æ˜¯`method with pointer`**

å½“ç„¶æ˜¯æœ‰ä¾‹å¤–çš„
todo

# empty interface ç©ºæ¥å£

æˆ‘è§‰å¾—åœ¨Goä¸­ï¼Œç©ºæ¥å£ä¸éç©ºæ¥å£å®Œå…¨è¡¨ç°ä¸ºä¸¤ç§ä¸åŒçš„äº‹ç‰©ï¼Œæ‰€ä»¥æˆ‘æ‰“ç®—åˆ†å¼€æ¥è®¨è®ºã€‚

## ğŸš©å°½é‡é¿å…ä½¿ç”¨ç©ºæ¥å£ä½œä¸ºå‡½æ•°çš„å‚æ•°ç±»å‹

> ç©ºæ¥å£ä¸æä¾›ä»»ä½•ä¿¡æ¯ã€‚   â€”â€” Rob Pike, Goè¯­è¨€ä¹‹çˆ¶

# interface éç©ºæ¥å£

**ä¸­å¿ƒæ€æƒ³ï¼šæ¥å£ä¸­çš„æ–¹æ³•è¶Šå¤šï¼Œè¿™ä¸ªæ¥å£è¶Šä¸é€šç”¨**

> The bigger the interface, the weaker the abstraction.

## ğŸŒµname
é€šå¸¸æ¥è¯´ï¼Œå¦‚æœ`interface`åªæœ‰ä¸€ä¸ª`method`ï¼Œé‚£ä¹ˆè¯¥`interface`çš„åå­—ï¼š`method`çš„åç§°`+er`ï¼Œæ¯”å¦‚`Reader`ã€`Writer` ç­‰ç­‰

> By convention, one-method interfaces are named by the method name plus an -er suffix or

## ğŸŒµæ˜¾å¼éªŒè¯ï¼šæŸä¸ªç±»å‹å®ç°æŒ‡å®šçš„æ¥å£
```go
// éªŒè¯structAæ˜¯å¦å®ç°äº†interfaceA
var _ interfaceA = (*structA)(nil)
```
ä½“ç°äº†`interface`ç±»å‹çš„é™æ€æ€§ã€‚

æ—¢ç„¶æ˜¯é™æ€æ€§ï¼Œä¹Ÿå°±æ˜¯ç¼–è¯‘æœŸé—´çš„æ£€æŸ¥ï¼Œä¸€äº›è¿è¡Œæ—¶çš„å‡ºé”™å°±åœ¨æ‰€éš¾å…ã€‚

æ‰€è°“çš„è¿è¡Œæ—¶é”™è¯¯ï¼Œé‚£å°±æ˜¯å†…åµŒ`interface`çš„æ—¶å€™ã€‚
```go
type MyStruct struct{}

// å†…åµŒerror interface
type MyError struct {
	error
}

func main() {
	var _ error = (*MyStruct)(nil) // *MyStruct does not implement error (missing Error method)
	
	var _ error = (*MyError)(nil) // ok 
	
	var e error = &MyError{}  // ok

	fmt.Println(e.Error()) // panic: runtime error: invalid memory address or nil pointer dereference
}
```

## ğŸš©å†…åµŒinterface

å†…åµŒ`interface`ä¸€å…±åˆ†ä¸ºä¸¤ç§å½¢å¼

* `interface`å†…åµŒ`interface`
* `struct`å†…åµŒ`interface`

ç¬¬ä¸€ç§ï¼Œ`interface`å†…åµŒ`interface`å¾ˆå¸¸è§ï¼Œä¹Ÿå¾ˆå®¹æ˜“ç†è§£ã€‚æ¯”å¦‚
```go
// io/io.go
type Reader interface {
	Read(p []byte) (n int, err error)
}

type Writer interface {
	Write(p []byte) (n int, err error)
}

// å†…åµŒinterfaceï¼Œæ‰©å¤§interfaceçš„æ–¹æ³•
type ReadWriter interface {
	Reader
	Writer
}
```

å…³é”®åœ¨äºç¬¬äºŒç§ï¼Œ`struct`å†…åµŒ`interface`ï¼Œè¿™æ˜¯ä»€ä¹ˆç»„åˆï¼Ÿè¿™æœ‰ä»€ä¹ˆé“ç†ï¼Ÿ
todo:[æ–‡ç« é˜…è¯»](https://eli.thegreenplace.net/2020/embedding-in-go-part-3-interfaces-in-structs)/


## ğŸš©å½“å¿ƒç›´æ¥è¿”å›interfaceçš„æƒ…å†µ
```go
type MyError struct {
	error
}

var ErrBad = MyError{
	error: errors.New("bad error"),
}

func bad() bool {
	return false
}

func returnsError() error {
	var p *MyError = nil // ğŸ“¢
	if bad() {
		p = &ErrBad
	}
	return p
}

func main() {
	e := returnsError()
	if e != nil {
		fmt.Printf("error: %+v\n", e) // error: <nil>
		return
	}
	fmt.Println("ok")
}
```
ä½“ç°äº†`interface`çš„åŠ¨æ€æ€§

å…¶åŠ¨æ€æ€§åŒ…å«ä¸¤éƒ¨åˆ†ï¼šåŠ¨æ€ç±»å‹ã€åŠ¨æ€ç±»å‹çš„å€¼ã€‚

æ­¤ä¾‹å­å°±æ˜¯å› ä¸ºè¿”å›çš„`error`æ¥å£ç±»å‹çš„åŠ¨æ€ç±»å‹ä¸ä¸º`nil`ï¼Œ`main`é‡Œé¢çš„`e`å°±ä¸ä¸º`nil`ã€‚

## ğŸš©å°½é‡å®šä¹‰å°æ¥å£

> æ¥å£è¶Šå¤§ï¼ŒæŠ½è±¡ç¨‹åº¦è¶Šä½ã€‚ï¼ˆä¸€ä¸ªäººçš„èƒ½åŠ›è¶Šå¤§ï¼Œä»–çš„è´£ä»»ä¹Ÿå°±è¶Šå¤§ï¼‰

ä½†æ˜¯æˆ‘ä»¬ä¸å¾—ä¸è¯´ï¼Œåœ¨é¡¹ç›®åˆæœŸï¼Œå¾ˆéš¾åˆ†è¾¨å’ŒæŠ½è±¡å‡ºå®ç”¨çš„å°æ¥å£ã€‚ä¹Ÿå°±æ˜¯è¯´åˆæœŸå¯ä¸åœ¨æ„æ¥å£çš„å¤§å°ï¼Œå› ä¸ºå¯¹é—®é¢˜çš„ç†è§£æ˜¯å¾ªåºæ¸è¿›çš„ï¼Œæ¯•ç«Ÿæ ‡å‡†åº“çš„`io.Reader/io.Writer`ä¹Ÿä¸æ˜¯ä¸€å¼€å§‹å°±ç¡®å®šçš„ã€‚




# å‚è€ƒ
* `ç™½æ˜ã€ŠGoè¯­è¨€ç²¾è¿›ä¹‹è·¯ã€‹(ğŸ“š)`
* `[100 go mistakes](ğŸ“š)`
* [Uber Go Style Guide](https://github.com/uber-go/guide/blob/master/style.md)
* [Effective Go](https://go.dev/doc/effective_go)
* [Embedding in Go: Part 3 - interfaces in structs](https://eli.thegreenplace.net/2020/embedding-in-go-part-3-interfaces-in-structs/)

